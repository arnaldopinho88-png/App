<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ALPS Vistoria ‚Äî Carimbo + ZIP</title>
  <meta name="theme-color" content="#111827" />
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 0; background:#0b1020; color:#eef2ff; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 16px; }
    .card { background:#111827; border:1px solid #243047; border-radius:14px; padding: 14px; margin-bottom: 12px; }
    h2,h3 { margin: 0 0 10px; }
    label { display:block; font-size: 12px; opacity:.9; margin-bottom:6px; }
    input, select { width:100%; padding: 12px; border-radius: 12px; border:1px solid #2b3a55; background:#0b1225; color:#eef2ff; font-size:16px; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .btn { width:100%; padding: 14px; border-radius: 14px; border:0; font-size: 16px; font-weight: 650; cursor:pointer; }
    .btn.primary { background:#3b82f6; color:white; }
    .btn.danger { background:#ef4444; color:white; }
    .btn.secondary { background:#111827; border:1px solid #2b3a55; color:#eef2ff; }
    .btn.small { padding: 10px; font-size: 14px; border-radius: 12px; }
    .hint { font-size: 12px; opacity:.85; margin-top: 8px; line-height: 1.35; }
    .status { font-size: 13px; opacity:.95; margin-top: 8px; }
    .pill { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid #2b3a55; background:#0b1225; font-size:12px; }
    .pill.ok { border-color:#14532d; background:#052e16; }
    .pill.warn { border-color:#78350f; background:#2a1503; }
    .pill.bad { border-color:#7f1d1d; background:#2a0c0c; }
    .grid { display:grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
    .roomList { display:grid; grid-template-columns: 1fr; gap: 8px; }
    .roomItem { display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px; border-radius:12px; border:1px solid #2b3a55; background:#0b1225; }
    .roomItem .left { display:flex; flex-direction:column; gap:4px; }
    .roomItem .title { font-weight: 700; }
    .roomItem .sub { font-size: 12px; opacity:.85; }
    .thumb { width:100%; border-radius: 12px; border:1px solid #2b3a55; background:#0b1225; overflow:hidden; }
    .thumb img { width:100%; display:block; }
    .thumb .meta { padding: 8px; font-size: 12px; opacity:.9; display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    .star { cursor:pointer; user-select:none; font-size: 18px; }
    .divider { height:1px; background:#243047; margin: 10px 0; }
    .counter { display:flex; align-items:center; gap:8px; }
    .miniBtn { width: 44px; height: 44px; border-radius: 12px; border:1px solid #2b3a55; background:#111827; color:#eef2ff; font-size: 18px; cursor:pointer; }
    .miniBtn:disabled { opacity:.45; cursor:not-allowed; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .switchRow{ display:flex; gap:10px; align-items:center; justify-content:space-between; padding:10px; border-radius:12px; border:1px solid #2b3a55; background:#0b1225; margin-top:10px; }
    .switchRow .txt{ display:flex; flex-direction:column; gap:2px; }
    .toggle{ width:54px; height:32px; border-radius:999px; background:#1f2a44; border:1px solid #2b3a55; position:relative; cursor:pointer; flex:0 0 auto; }
    .toggle::after{ content:""; width:26px; height:26px; background:#eef2ff; border-radius:999px; position:absolute; top:2px; left:2px; transition: all .15s ease; }
    .toggle.on{ background:#2563eb; border-color:#1d4ed8; }
    .toggle.on::after{ left:26px; }
    .chipRow{ display:flex; gap:10px; flex-wrap:wrap; }
    @media (max-width: 740px) { .row { grid-template-columns: 1fr; } .grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">

    <!-- SETUP -->
    <div class="card" id="setupCard">
      <h2>üß± Setup da Vistoria</h2>

      <div class="row">
        <div>
          <label>Ordem de Servi√ßo (OS) *</label>
          <input id="os" placeholder="Ex.: OS-2026-017" />
        </div>
        <div>
          <label>ID do Laudo (opcional)</label>
          <input id="laudoId" placeholder="Ex.: LAUDO-045" />
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Cliente/Obra (opcional)</label>
          <input id="cliente" placeholder="Ex.: Condom√≠nio X / Apto 34" />
        </div>
        <div>
          <label>Formato do carimbo</label>
          <select id="mode">
            <option value="coordsAccuracy">Data/hora + Coordenadas + Precis√£o</option>
            <option value="coords">Data/hora + Coordenadas</option>
          </select>
        </div>
      </div>

      <div class="switchRow" style="margin-top:12px;">
        <div class="txt">
          <div style="font-weight:700;">üõü Backup interno autom√°tico (plano B)</div>
          <div class="hint" style="margin:0;">
            Guarda uma c√≥pia de cada foto carimbada no <b>cofre do app</b> (IndexedDB).
            Voc√™ consegue abrir pelo bot√£o ‚ÄúüìÇ Abrir Backup no App‚Äù e apagar depois.
          </div>
        </div>
        <div id="togBackup" class="toggle on" title="Ligar/desligar"></div>
      </div>

      <div class="divider"></div>

      <h3>üè† Composi√ß√£o do im√≥vel</h3>
      <div class="hint" style="margin-top:0;">
        Ajuste as quantidades com <span class="mono">‚Äì</span> e <span class="mono">+</span>.
        <br><b>Fachada pode aumentar/diminuir, mas nunca fica abaixo de 1.</b>
      </div>

      <div id="roomCounters" class="roomList" style="margin-top:10px;"></div>

      <div class="row" style="margin-top:10px;">
        <button class="btn secondary" id="btnAddRoom">‚ûï Adicionar outro c√¥modo</button>
        <button class="btn primary" id="btnStart">‚ñ∂Ô∏è Iniciar Vistoria</button>
      </div>

      <div class="status" id="setupStatus"></div>
    </div>

    <!-- VISTORIA -->
    <div class="card" id="vistoriaCard" style="display:none;">
      <h2>üì∏ Modo Vistoria</h2>

      <div class="chipRow">
        <span class="pill" id="pillOs"></span>
        <span class="pill" id="pillLoc">üìç Localiza√ß√£o: n√£o coletada</span>
        <span class="pill" id="pillFachada"></span>
        <span class="pill warn" id="pillBackup">üõü Backup: ligado</span>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn secondary" id="btnLoc">üìç Testar localiza√ß√£o</button>
        <button class="btn secondary" id="btnUnlock">üîì Reabrir edi√ß√£o</button>
      </div>

      <div class="divider"></div>

      <div class="row">
        <button class="btn secondary" id="btnOpenBackup">üìÇ Abrir Backup no App</button>
        <button class="btn danger" id="btnDeleteBackupOS">üßπ Apagar Backup desta OS</button>
      </div>

      <div class="hint">
        Tire fotos por c√¥modo. ‚≠ê marca a melhor do c√¥modo. Voc√™ pode exportar ZIP e compartilhar.
      </div>

      <div class="divider"></div>

      <h3>‚úÖ C√¥modos</h3>
      <div id="rooms" class="roomList"></div>

      <div class="divider"></div>

      <div class="row">
        <button class="btn secondary" id="btnExportZip">üì¶ Baixar ZIP</button>
        <button class="btn primary" id="btnShareZip">üì§ Compartilhar ZIP</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn secondary" id="btnExportJson">üì§ Exportar JSON</button>
        <button class="btn primary" id="btnFinish">‚úÖ Finalizar</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn danger" id="btnClearTop">üßπ Limpar tudo</button>
      </div>

      <div class="status" id="finishStatus"></div>
    </div>

    <!-- GALERIA DO APP (sess√£o atual) -->
    <div class="card" id="galleryCard" style="display:none;">
      <h3>üìÇ Galeria ‚Äî sess√£o atual</h3>
      <div class="hint" style="margin-top:0;">
        Isso √© a sess√£o atual. O <b>Backup</b> √© separado e fica em ‚ÄúAbrir Backup no App‚Äù.
      </div>
      <div id="gallery" class="grid" style="margin-top:10px;"></div>
    </div>

    <!-- BACKUP VIEW -->
    <div class="card" id="backupCard" style="display:none;">
      <h3>üõü Backup no App</h3>
      <div class="hint" style="margin-top:0;">
        Aqui ficam as c√≥pias de seguran√ßa (plano B). Voc√™ pode baixar/compartilhar cada uma e apagar quando quiser.
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn secondary" id="btnBackToVistoria">‚¨ÖÔ∏è Voltar</button>
        <button class="btn danger" id="btnDeleteBackupAll">üßπ Apagar TODOS os backups</button>
      </div>

      <div class="status" id="backupStatus"></div>
      <div id="backupList" class="grid" style="margin-top:10px;"></div>
    </div>

    <input id="file" type="file" accept="image/*" capture="environment" style="display:none;" />

  </div>

  <!-- JSZip (precisa internet para ZIP) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
  const el = (id) => document.getElementById(id);

  const state = {
    locked: false,
    config: { os: "", laudoId: "", cliente: "", mode: "coordsAccuracy" },
    options: { backupOn: true },
    templates: [
      { key: "Fachada", label: "Fachada", count: 1, required: true },
      { key: "Sala", label: "Sala", count: 1, required: false },
      { key: "Cozinha", label: "Cozinha", count: 1, required: false },
      { key: "Quarto", label: "Quarto", count: 3, required: false },
      { key: "Su√≠te", label: "Su√≠te", count: 1, required: false },
      { key: "Banheiro", label: "Banheiro", count: 2, required: false },
      { key: "Varanda", label: "Varanda", count: 1, required: false },
      { key: "√Årea de Servi√ßo", label: "√Årea de Servi√ßo", count: 1, required: false },
      { key: "Garagem", label: "Garagem", count: 0, required: false }
    ],
    rooms: [],
    activeRoomId: null,
    lastPos: null,
  };

  // ---------- IndexedDB (Backup cofre do app) ----------
  const DB_NAME = "alps_vistoria_backup_v1";
  const STORE = "photos";

  function openDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        const st = db.createObjectStore(STORE, { keyPath: "id" });
        st.createIndex("by_os", "os", { unique: false });
        st.createIndex("by_created", "createdAt", { unique: false });
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function dbPutPhoto(record) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readwrite");
      tx.objectStore(STORE).put(record);
      tx.oncomplete = () => { db.close(); resolve(true); };
      tx.onerror = () => { db.close(); reject(tx.error); };
    });
  }

  async function dbListPhotos(osFilter=null) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readonly");
      const st = tx.objectStore(STORE);
      const idx = st.index("by_created");
      const out = [];

      const req = idx.openCursor(null, "prev"); // mais recentes primeiro
      req.onsuccess = () => {
        const cur = req.result;
        if (!cur) { db.close(); resolve(out); return; }
        const v = cur.value;
        if (!osFilter || v.os === osFilter) out.push(v);
        cur.continue();
      };
      req.onerror = () => { db.close(); reject(req.error); };
    });
  }

  async function dbDeleteByOS(os) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readwrite");
      const st = tx.objectStore(STORE);
      const idx = st.index("by_os");
      const req = idx.openCursor(IDBKeyRange.only(os));
      req.onsuccess = () => {
        const cur = req.result;
        if (!cur) { return; }
        st.delete(cur.primaryKey);
        cur.continue();
      };
      tx.oncomplete = () => { db.close(); resolve(true); };
      tx.onerror = () => { db.close(); reject(tx.error); };
    });
  }

  async function dbDeleteAll() {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readwrite");
      tx.objectStore(STORE).clear();
      tx.oncomplete = () => { db.close(); resolve(true); };
      tx.onerror = () => { db.close(); reject(tx.error); };
    });
  }

  // ---------- helpers ----------
  function pad(n){ return String(n).padStart(2,"0"); }
  function fmtDate(d){ return `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`; }
  function fmtCoord(n){ return (Math.round(n * 1e6) / 1e6).toFixed(6); }

  function ensureOS() {
    const os = el("os").value.trim();
    if (!os) { alert("Informe a Ordem de Servi√ßo (OS)."); el("os").focus(); return null; }
    return os;
  }

  async function getPosition() {
    if (!navigator.geolocation) throw new Error("Geolocaliza√ß√£o n√£o suportada.");
    return await new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(resolve, reject, {
        enableHighAccuracy: true, timeout: 15000, maximumAge: 5000
      });
    });
  }

  function updateLocPill(text, level="warn") {
    const pill = el("pillLoc");
    pill.className = "pill " + (level==="ok" ? "ok" : level==="bad" ? "bad" : "warn");
    pill.textContent = text;
  }

  function updateBackupPill() {
    const pill = el("pillBackup");
    pill.className = "pill " + (state.options.backupOn ? "ok" : "warn");
    pill.textContent = state.options.backupOn ? "üõü Backup: ligado" : "üõü Backup: desligado";
    el("togBackup").className = "toggle " + (state.options.backupOn ? "on" : "");
  }

  async function testLocation() {
    try {
      updateLocPill("üìç Localiza√ß√£o: coletando‚Ä¶", "warn");
      const pos = await getPosition();
      const lat = pos.coords.latitude, lng = pos.coords.longitude, acc = pos.coords.accuracy;
      state.lastPos = { lat, lng, acc, timestamp: Date.now() };
      updateLocPill(`üìç OK: ${fmtCoord(lat)}, ${fmtCoord(lng)} (¬±${Math.round(acc)} m)`, "ok");
    } catch (e) {
      updateLocPill(`üìç Falhou: ${e.message}`, "bad");
    }
  }

  async function loadImageFromFile(file) {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.src = url;
    await new Promise((res, rej) => { img.onload = res; img.onerror = rej; });
    return img;
  }

  function drawOverlay(ctx, w, h, lines) {
    const padding = Math.max(16, Math.round(w * 0.02));
    const fontSize = Math.max(16, Math.round(w * 0.03));
    const lineH = Math.max(20, Math.round(fontSize * 1.05));
    const boxH = padding*2 + lineH*lines.length;

    ctx.save();
    ctx.globalAlpha = 0.78;
    ctx.fillStyle = "#000";
    ctx.fillRect(0, h - boxH, w, boxH);
    ctx.globalAlpha = 1;

    ctx.fillStyle = "#fff";
    ctx.font = `700 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textBaseline = "top";

    let y = h - boxH + padding;
    for (const line of lines) {
      ctx.fillText(line, padding, y);
      y += lineH;
    }
    ctx.restore();
  }

  function isFachadaLabel(label) {
    return String(label || "").toLowerCase().includes("fachada");
  }

  function sanitizeForFilename(s) {
    return String(s || "")
      .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
      .replace(/[^a-zA-Z0-9_-]+/g, "_")
      .replace(/^_+|_+$/g, "")
      .slice(0, 60) || "item";
  }

  function makePhotoFilename(os, roomLabel, roomPhotoIndex1Based) {
    const osSafe = sanitizeForFilename(os);
    const roomSafe = sanitizeForFilename(roomLabel);
    const seq = pad(roomPhotoIndex1Based);
    return `${osSafe}_${roomSafe}_${seq}.jpg`;
  }

  async function stampPhoto(file, roomLabel) {
    const capturedAt = new Date();

    let pos = null;
    try {
      const p = await getPosition();
      pos = { lat: p.coords.latitude, lng: p.coords.longitude, acc: p.coords.accuracy };
      state.lastPos = { ...pos, timestamp: Date.now() };
      updateLocPill(`üìç OK: ${fmtCoord(pos.lat)}, ${fmtCoord(pos.lng)} (¬±${Math.round(pos.acc)} m)`, "ok");
    } catch {
      updateLocPill("üìç Sem GPS no clique", "warn");
    }

    const img = await loadImageFromFile(file);
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    ctx.drawImage(img, 0, 0);

    const { os, laudoId, cliente, mode } = state.config;
    const lines = [];
    lines.push(`OS: ${os}${laudoId ? " | ID: " + laudoId : ""}${cliente ? " | " + cliente : ""}`);
    lines.push(`C√¥modo: ${roomLabel} | Data/Hora: ${fmtDate(capturedAt)}`);

    if (pos) {
      const base = `GPS: ${fmtCoord(pos.lat)}, ${fmtCoord(pos.lng)}`;
      lines.push(mode === "coordsAccuracy" ? `${base} (¬±${Math.round(pos.acc)} m)` : base);
    } else {
      lines.push("GPS: (indispon√≠vel)");
    }

    drawOverlay(ctx, canvas.width, canvas.height, lines);
    const blob = await new Promise(res => canvas.toBlob(res, "image/jpeg", 0.92));

    return { blob, capturedAtISO: capturedAt.toISOString(), roomLabel, gps: pos ? { ...pos } : null };
  }

  function refreshFachadaStatus() {
    const fachadas = state.rooms.filter(r => isFachadaLabel(r.label));
    const totalFotos = fachadas.reduce((sum, r) => sum + r.photos.length, 0);
    const ok = totalFotos > 0;

    const pill = el("pillFachada");
    pill.className = "pill " + (ok ? "ok" : "bad");
    pill.textContent = ok
      ? `‚úÖ Fachada OK (${totalFotos} foto(s))`
      : "‚ùå Fachada obrigat√≥ria (falta pelo menos 1 foto)";
  }

  function renderRoomCounters() {
    const wrap = el("roomCounters");
    wrap.innerHTML = "";

    state.templates.forEach((t, idx) => {
      const isFachada = isFachadaLabel(t.label);
      const badge = isFachada
        ? '<span class="pill bad" style="margin-left:8px;">M√≠n. 1</span>'
        : (t.required ? '<span class="pill bad" style="margin-left:8px;">Obrigat√≥ria</span>' : '');

      const row = document.createElement("div");
      row.className = "roomItem";
      row.innerHTML = `
        <div class="left">
          <div class="title">${t.label} ${badge}</div>
          <div class="sub">Quantidade: <span class="mono">${t.count}</span></div>
        </div>
        <div class="counter">
          <button class="miniBtn" data-act="minus" data-idx="${idx}" ${state.locked ? "disabled" : ""}>‚Äì</button>
          <button class="miniBtn" data-act="plus" data-idx="${idx}" ${state.locked ? "disabled" : ""}>+</button>
        </div>
      `;
      wrap.appendChild(row);
    });

    wrap.querySelectorAll("button[data-act]").forEach(btn => {
      btn.addEventListener("click", () => {
        const act = btn.getAttribute("data-act");
        const i = Number(btn.getAttribute("data-idx"));
        const t = state.templates[i];

        if (act === "minus") {
          const min = isFachadaLabel(t.label) ? 1 : 0;
          t.count = Math.max(min, Number(t.count) - 1);
        } else if (act === "plus") {
          t.count = Math.min(20, Number(t.count) + 1);
        }
        renderRoomCounters();
      });
    });
  }

  function buildRoomsFromCounters() {
    const rooms = [];
    for (const t of state.templates) {
      if (Number(t.count) <= 0) continue;

      if (isFachadaLabel(t.label)) {
        if (Number(t.count) === 1) {
          rooms.push({ id: crypto.randomUUID(), label: "Fachada", required: true, photos: [] });
        } else {
          for (let i=1;i<=Number(t.count);i++) {
            rooms.push({ id: crypto.randomUUID(), label: `Fachada ${i}`, required: true, photos: [] });
          }
        }
        continue;
      }

      if (Number(t.count) === 1) {
        rooms.push({ id: crypto.randomUUID(), label: t.label, required: !!t.required, photos: [] });
      } else {
        for (let i=1;i<=Number(t.count);i++) {
          rooms.push({ id: crypto.randomUUID(), label: `${t.label} ${i}`, required: !!t.required, photos: [] });
        }
      }
    }

    if (!rooms.some(r => isFachadaLabel(r.label))) {
      rooms.unshift({ id: crypto.randomUUID(), label: "Fachada", required: true, photos: [] });
    }

    rooms.sort((a,b) => (isFachadaLabel(a.label) === isFachadaLabel(b.label)) ? 0 : isFachadaLabel(a.label) ? -1 : 1);
    state.rooms = rooms;
  }

  function renderRooms() {
    const wrap = el("rooms");
    wrap.innerHTML = "";

    state.rooms.forEach(r => {
      const count = r.photos.length;
      const fachada = isFachadaLabel(r.label);

      const badge = fachada
        ? (count>0 ? `<span class="pill ok">‚úÖ ok</span>` : `<span class="pill bad">‚ùå obrigat√≥rio</span>`)
        : (count>0 ? `<span class="pill ok">üì∏ ${count}</span>` : `<span class="pill warn">0 fotos</span>`);

      const div = document.createElement("div");
      div.className = "roomItem";
      div.innerHTML = `
        <div class="left">
          <div class="title">${r.label} ${fachada ? '<span class="pill bad" style="margin-left:8px;">Obrigat√≥ria</span>' : ""}</div>
          <div class="sub">${count} foto(s)</div>
        </div>
        <div style="display:flex; gap:10px; align-items:center;">
          ${badge}
          <button class="btn small secondary" data-room="${r.id}">üì∑ Foto</button>
        </div>
      `;
      wrap.appendChild(div);
    });

    wrap.querySelectorAll("button[data-room]").forEach(btn => {
      btn.addEventListener("click", () => {
        state.activeRoomId = btn.getAttribute("data-room");
        el("file").click();
      });
    });

    refreshFachadaStatus();
  }

  function renderGallery() {
    const g = el("gallery");
    g.innerHTML = "";

    const all = [];
    for (const room of state.rooms) room.photos.forEach((p) => all.push({ room, p }));
    all.reverse().forEach(({room, p}) => {
      const div = document.createElement("div");
      div.className = "thumb";
      const star = p.best ? "‚≠ê" : "‚òÜ";
      const gpsText = p.gps ? `¬±${Math.round(p.gps.acc)}m` : "sem GPS";
      div.innerHTML = `
        <img src="${p.url}" alt="carimbada">
        <div class="meta">
          <div>
            <div><b>${room.label}</b></div>
            <div class="small">${fmtDate(new Date(p.capturedAtISO))} ‚Äî ${gpsText}</div>
            <div class="small mono">${p.filename}</div>
          </div>
          <div style="display:flex; gap:10px; align-items:center;">
            <span class="star" title="Marcar melhor foto" data-star="${room.id}::${p.id}">${star}</span>
            <a download="${p.filename}" href="${p.url}" style="color:#93c5fd;">‚¨áÔ∏è</a>
          </div>
        </div>
      `;
      g.appendChild(div);
    });

    g.querySelectorAll("[data-star]").forEach(s => {
      s.addEventListener("click", () => {
        const [roomId, photoId] = s.getAttribute("data-star").split("::");
        const room = state.rooms.find(r => r.id === roomId);
        if (!room) return;
        room.photos.forEach(ph => ph.best = false);
        const ph = room.photos.find(ph => ph.id === photoId);
        if (ph) ph.best = true;
        renderGallery();
      });
    });
  }

  function lockConfig(lock) {
    state.locked = lock;
    ["os","laudoId","cliente","mode"].forEach(id => el(id).disabled = lock);
    el("btnAddRoom").disabled = lock;
    renderRoomCounters();

    el("setupStatus").textContent = lock
      ? "Config travada. Use ‚ÄúReabrir edi√ß√£o‚Äù se precisar."
      : "";
  }

  function showVistoria() {
    el("setupCard").style.display = "none";
    el("vistoriaCard").style.display = "";
    el("galleryCard").style.display = "";
    el("backupCard").style.display = "none";

    el("pillOs").className = "pill ok";
    el("pillOs").textContent = `OS: ${state.config.os}${state.config.laudoId ? " | ID: " + state.config.laudoId : ""}`;
    updateBackupPill();

    refreshFachadaStatus();
    renderRooms();
    renderGallery();
  }

  function showBackup() {
    el("backupCard").style.display = "";
    el("vistoriaCard").style.display = "none";
    el("galleryCard").style.display = "none";
  }

  function validateFachada() {
    const fachadas = state.rooms.filter(r => isFachadaLabel(r.label));
    const totalFotos = fachadas.reduce((sum, r) => sum + r.photos.length, 0);
    return totalFotos > 0;
  }

  function buildManifestData() {
    let globalOrder = 0;
    const rows = [];
    const roomsOut = [];

    for (const room of state.rooms) {
      const photosOut = [];
      room.photos.forEach((p, idx) => {
        globalOrder += 1;
        rows.push({
          ordem: globalOrder,
          comodo: room.label,
          foto_idx: idx + 1,
          best: p.best ? 1 : 0,
          arquivo: p.filename,
          capturedAtISO: p.capturedAtISO,
          lat: p.gps ? p.gps.lat : "",
          lng: p.gps ? p.gps.lng : "",
          acc_m: p.gps ? Math.round(p.gps.acc) : ""
        });
        photosOut.push({
          id: p.id,
          filename: p.filename,
          best: !!p.best,
          capturedAtISO: p.capturedAtISO,
          gps: p.gps || null
        });
      });

      roomsOut.push({ label: room.label, required: !!room.required, photos: photosOut });
    }

    const json = { config: state.config, createdAt: new Date().toISOString(), rooms: roomsOut };
    return { rows, json };
  }

  function toCSV(rows) {
    const header = ["ordem","comodo","foto_idx","best","arquivo","capturedAtISO","lat","lng","acc_m"];
    const esc = (v) => {
      const s = String(v ?? "");
      if (/[",\n;]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
      return s;
    };
    const lines = [header.join(",")];
    for (const r of rows) lines.push(header.map(h => esc(r[h])).join(","));
    return lines.join("\n");
  }

  async function buildZipAll() {
    if (typeof JSZip === "undefined") {
      alert("Biblioteca ZIP n√£o carregou. Verifique internet.");
      return null;
    }
    if (!validateFachada()) {
      alert("Falta pelo menos 1 foto de fachada.");
      return null;
    }

    const { rows, json } = buildManifestData();
    const csv = toCSV(rows);

    const zip = new JSZip();
    const osSafe = sanitizeForFilename(state.config.os || "OS");
    zip.file("manifesto.csv", csv);
    zip.file("manifesto.json", JSON.stringify(json, null, 2));

    const imgFolder = zip.folder("images");
    for (const room of state.rooms) {
      for (const p of room.photos) {
        if (!p.blob) continue;
        imgFolder.file(p.filename, p.blob);
      }
    }

    const blobZip = await zip.generateAsync({ type: "blob" });
    const filename = `${osSafe}_vistoria.zip`;
    return { blobZip, filename };
  }

  async function downloadZipAll() {
    const pack = await buildZipAll();
    if (!pack) return;
    const url = URL.createObjectURL(pack.blobZip);
    const a = document.createElement("a");
    a.href = url;
    a.download = pack.filename;
    a.click();
    URL.revokeObjectURL(url);
  }

  async function shareZipAll() {
    const pack = await buildZipAll();
    if (!pack) return;

    const file = new File([pack.blobZip], pack.filename, { type: "application/zip" });

    if (navigator.canShare && navigator.canShare({ files: [file] }) && navigator.share) {
      try {
        await navigator.share({
          title: `Vistoria ${state.config.os}`,
          text: `ZIP da vistoria (${state.config.os}) com imagens e manifestos.`,
          files: [file],
        });
        return;
      } catch {}
    }

    alert("Seu navegador n√£o suportou compartilhamento direto do arquivo. Vou baixar o ZIP normalmente.");
    await downloadZipAll();
  }

  function exportJsonOnly() {
    const { json } = buildManifestData();
    const blob = new Blob([JSON.stringify(json, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${sanitizeForFilename(state.config.os)}_vistoria.json`;
    a.click();
    URL.revokeObjectURL(url);
  }

  function clearAll() {
    for (const r of state.rooms) for (const p of r.photos) URL.revokeObjectURL(p.url);
    state.rooms = [];
    state.activeRoomId = null;
    state.locked = false;
    state.config = { os:"", laudoId:"", cliente:"", mode:"coordsAccuracy" };
    el("os").value = "";
    el("laudoId").value = "";
    el("cliente").value = "";
    el("mode").value = "coordsAccuracy";
    lockConfig(false);
    el("setupCard").style.display = "";
    el("vistoriaCard").style.display = "none";
    el("galleryCard").style.display = "none";
    el("backupCard").style.display = "none";
    el("finishStatus").textContent = "";
    updateLocPill("üìç Localiza√ß√£o: n√£o coletada", "warn");
  }

  // ---------- Backup UI ----------
  async function refreshBackupUI(osFilter=null) {
    const list = el("backupList");
    list.innerHTML = "";
    const items = await dbListPhotos(osFilter);
    el("backupStatus").textContent = items.length
      ? `${items.length} item(ns) no backup${osFilter ? " (OS atual)" : ""}.`
      : `Nenhum item no backup${osFilter ? " (OS atual)" : ""}.`;

    for (const it of items) {
      const url = URL.createObjectURL(it.blob);
      const div = document.createElement("div");
      div.className = "thumb";
      const gpsText = it.gps ? `¬±${Math.round(it.gps.acc)}m` : "sem GPS";
      div.innerHTML = `
        <img src="${url}" alt="backup">
        <div class="meta">
          <div>
            <div><b>${it.roomLabel}</b> <span class="mono">(${it.os})</span></div>
            <div class="small">${fmtDate(new Date(it.capturedAtISO))} ‚Äî ${gpsText}</div>
            <div class="small mono">${it.filename}</div>
          </div>
          <div style="display:flex; gap:10px; align-items:center;">
            <a download="${it.filename}" href="${url}" style="color:#93c5fd;">‚¨áÔ∏è</a>
          </div>
        </div>
      `;
      list.appendChild(div);
    }
  }

  // ---------- Eventos ----------
  el("togBackup").addEventListener("click", () => {
    state.options.backupOn = !state.options.backupOn;
    updateBackupPill();
  });

  el("btnLoc").addEventListener("click", testLocation);

  el("btnAddRoom").addEventListener("click", () => {
    const name = prompt("Nome do c√¥modo (ex.: Escrit√≥rio, Quintal, Corredor):");
    if (!name) return;
    state.templates.push({ key: name, label: name, count: 1, required: false });
    renderRoomCounters();
  });

  el("btnStart").addEventListener("click", () => {
    const os = ensureOS();
    if (!os) return;

    state.config.os = os;
    state.config.laudoId = el("laudoId").value.trim();
    state.config.cliente = el("cliente").value.trim();
    state.config.mode = el("mode").value;

    buildRoomsFromCounters();
    lockConfig(true);
    showVistoria();
  });

  el("btnUnlock").addEventListener("click", () => {
    const ok = confirm("Reabrir edi√ß√£o destrava OS/ID e os c√¥modos. Continuar?");
    if (!ok) return;
    lockConfig(false);
    el("setupCard").style.display = "";
    el("vistoriaCard").style.display = "none";
    el("galleryCard").style.display = "none";
    el("backupCard").style.display = "none";
    el("setupStatus").textContent = "Edite e clique novamente em ‚ÄúIniciar Vistoria‚Äù.";
  });

  el("btnExportZip").addEventListener("click", downloadZipAll);
  el("btnShareZip").addEventListener("click", shareZipAll);
  el("btnExportJson").addEventListener("click", exportJsonOnly);

  el("btnFinish").addEventListener("click", () => {
    const okFachada = validateFachada();
    const s = el("finishStatus");
    if (!okFachada) {
      s.textContent = "‚ùå Falta pelo menos 1 foto de fachada.";
      s.style.color = "#fecaca";
      return;
    }
    s.textContent = "‚úÖ OK. Exporte/compartilhe o ZIP e (se quiser) apague o backup desta OS.";
    s.style.color = "#bbf7d0";
  });

  el("btnClearTop").addEventListener("click", () => {
    const ok = confirm("Tem certeza que deseja apagar tudo da sess√£o atual?");
    if (ok) clearAll();
  });

  el("btnOpenBackup").addEventListener("click", async () => {
    await refreshBackupUI(state.config.os);
    showBackup();
  });

  el("btnBackToVistoria").addEventListener("click", () => {
    showVistoria();
  });

  el("btnDeleteBackupOS").addEventListener("click", async () => {
    const os = state.config.os;
    if (!os) return alert("OS n√£o definida.");
    const ok = confirm(`Apagar TODOS os backups do app referentes √† OS ${os}?`);
    if (!ok) return;
    await dbDeleteByOS(os);
    alert("Backups desta OS apagados.");
  });

  el("btnDeleteBackupAll").addEventListener("click", async () => {
    const ok = confirm("Apagar TODOS os backups do app (todas as OS)?");
    if (!ok) return;
    await dbDeleteAll();
    await refreshBackupUI(null);
    alert("Todos os backups apagados.");
  });

  el("file").addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    e.target.value = "";
    if (!file) return;

    const room = state.rooms.find(r => r.id === state.activeRoomId);
    if (!room) return alert("Selecione um c√¥modo antes de tirar foto.");

    try {
      const stamped = await stampPhoto(file, room.label);
      const url = URL.createObjectURL(stamped.blob);

      const roomPhotoIndex = room.photos.length + 1;
      const filename = makePhotoFilename(state.config.os, room.label, roomPhotoIndex);

      const photoObj = {
        id: crypto.randomUUID(),
        url,
        blob: stamped.blob,
        filename,
        capturedAtISO: stamped.capturedAtISO,
        gps: stamped.gps,
        roomLabel: room.label,
        best: room.photos.length === 0
      };

      room.photos.push(photoObj);

      // ‚úÖ Backup interno autom√°tico (plano B)
      if (state.options.backupOn) {
        await dbPutPhoto({
          id: photoObj.id,
          os: state.config.os,
          roomLabel: photoObj.roomLabel,
          filename: photoObj.filename,
          capturedAtISO: photoObj.capturedAtISO,
          gps: photoObj.gps || null,
          createdAt: Date.now(),
          blob: photoObj.blob
        });
      }

      renderRooms();
      renderGallery();
    } catch (err) {
      alert("Erro ao carimbar foto: " + err.message);
    }
  });

  // ---------- init ----------
  renderRoomCounters();
  updateBackupPill();

  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("./sw.js").catch(() => {});
  }
</script>
</body>
</html>
